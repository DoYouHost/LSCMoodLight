---
substitutions:
  API_KEY: "cYLmor7J+H5rQShKbqnIjI1KY0s0+82G15gWjEQ+xQI="
  OTA_PASSWORD: "F6wfE@Gt!OrLIjlSp0Tg90wr1#*1oCGP"
  WEB_USERNAME: "esphome"
  WEB_PASSWORD: "esphome"
  AP_SSID: "LSC Moodlight"
  AP_PASSWORD: "esphome-fallback"

esphome:
  name: bk72_moodlight
  friendly_name: "LSC Moodlight"
  comment: "LSC Smart Connect Moodlight based on BK72"
  name_add_mac_suffix: true
  project:
    name: "DoYouHost.LSCMoodLight"
    version: "dev"

bk72xx:
  board: generic-bk7231n-qfn32-tuya

dashboard_import:
  package_import_url: github://DoYouHost/LSCMoodLight/bk72_moodlight.yaml@main
  import_full_config: false

packages:
  DoYouHost/ESPHomeTemplates:
    url: https://github.com/DoYouHost/ESPHomeTemplates
    files: 
      - basic.yaml
      - debug.yaml
      # - updateBetaProdStaging.yaml
      # - webServer3.yaml
      - wifiInfo.yaml
    ref: main
    refresh: 0d

logger:
  baud_rate: 0
  level: DEBUG
  logs:
    light: INFO
    sensor: INFO

wifi:
  reboot_timeout: 15min
  # enable_btm: true
  # enable_rrm: true
  ap: 
    ssid: "${AP_SSID}"
    password: "${AP_PASSWORD}"

captive_portal:

api:
  reboot_timeout: 15min
  encryption:
    key: "${API_KEY}"

ota:
  - platform: esphome
    password: "${OTA_PASSWORD}"
    on_begin:
      then:
        - light.turn_off: moodlight_light

binary_sensor:
  - platform: gpio
    name: "Mode Button"
    id: btn_mode
    pin:
      number: P8
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      then:
        - lambda: |-
            static int effect_idx = 0;
            static bool saved = false;
            static float prev_r = 0.0f, prev_g = 0.0f, prev_b = 0.0f, prev_w = 0.0f, prev_brightness = 0.75f;
            static bool prev_on = false;
            auto &rv = id(moodlight_light).remote_values;
            int next = (effect_idx + 1) % 4;
            if (effect_idx == 0 && next != 0 && !saved) {
              prev_on = rv.is_on();
              prev_r = rv.get_red();
              prev_g = rv.get_green();
              prev_b = rv.get_blue();
              prev_w = rv.get_white();
              prev_brightness = rv.get_brightness();
              saved = true;
            }
            if (next == 0) {
              saved = false;
              if (!prev_on) {
                id(moodlight_light).turn_off().perform();
              } else {
                auto call = id(moodlight_light).turn_on();
                call.set_transition_length(200);
                call.set_effect("None");
                call.set_rgb(prev_r, prev_g, prev_b);
                call.set_white(prev_w);
                call.set_brightness(prev_brightness);
                call.perform();
              }
            } else if (next == 1) {
              auto call = id(moodlight_light).turn_on();
              call.set_effect("Rainbow Cycle");
              call.perform();
            } else if (next == 2) {
              auto call = id(moodlight_light).turn_on();
              call.set_effect("Police Light");
              call.perform();
            } else if (next == 3) {
              auto call = id(moodlight_light).turn_on();
              call.set_effect("Fireplace");
              call.perform();
            }
            effect_idx = next;

  - platform: gpio
    name: "Music Button"
    id: btn_music
    pin:
      number: P9
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      then:
        - lambda: |-
            static bool sound_reactive = false;
            if (!sound_reactive) {
              auto call = id(moodlight_light).turn_on();
              call.set_effect("Sound Reactive");
              call.perform();
              sound_reactive = true;
            } else {
              sound_reactive = false;
              id(moodlight_light).turn_off().perform();
            }
  
  - platform: gpio
    name: "On/Off Button"
    id: btn_on_off
    pin:
      number: P14
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_press:
      then:
        - lambda: |-
            auto &rv = id(moodlight_light).remote_values;
            if (rv.is_on()) {
              auto off = id(moodlight_light).turn_off();
              off.perform();
            } else {
              auto call = id(moodlight_light).turn_on();
              call.set_transition_length(200);
              call.set_rgb(1.0f, 0.7f, 0.5f);
              call.set_white(0.75f);
              call.set_brightness(0.75f);
              call.perform();
            }

output:
  - platform: libretiny_pwm
    id: red_pwm
    pin: P6
    inverted: false
    zero_means_zero: true
    min_power: 0.00
    max_power: 1.00

  - platform: libretiny_pwm
    id: green_pwm
    pin: P7
    inverted: false
    zero_means_zero: true
    min_power: 0.00
    max_power: 1.00

  - platform: libretiny_pwm
    id: blue_pwm
    pin: P24
    inverted: false
    zero_means_zero: true
    min_power: 0.00
    max_power: 1.00

  - platform: libretiny_pwm
    id: white_pwm
    pin: P26
    inverted: false
    zero_means_zero: true
    min_power: 0.00
    max_power: 1.00

light:
  - platform: rgbw
    name: "Moodlight"
    id: moodlight_light
    red: red_pwm
    green: green_pwm
    blue: blue_pwm
    white: white_pwm
    default_transition_length: 1s
    restore_mode: RESTORE_DEFAULT_OFF

    effects:
      - lambda:
          name: "Rainbow Cycle"
          update_interval: 33ms
          lambda: |-
            static uint32_t start = esphome::millis();
            uint32_t now = esphome::millis();
            float cycle_s = id(rainbow_cycle_duration).state;
            if (cycle_s < 5.0f) cycle_s = 5.0f;
            if (cycle_s > 300.0f) cycle_s = 300.0f;
            uint32_t cycle = (uint32_t)(cycle_s * 1000.0f);
            uint32_t elapsed = (now - start) % cycle;
            float h = (float) elapsed / (float) cycle;
            float r, g, b;
            float i = floorf(h * 6.0f);
            float f = h * 6.0f - i;
            float q = 1.0f - f;
            switch ((int) i % 6) {
              case 0: r = 1; g = f; b = 0; break;
              case 1: r = q; g = 1; b = 0; break;
              case 2: r = 0; g = 1; b = f; break;
              case 3: r = 0; g = q; b = 1; break;
              case 4: r = f; g = 0; b = 1; break;
              case 5: r = 1; g = 0; b = q; break;
            }
            auto call = id(moodlight_light).turn_on();
            call.set_transition_length(0);
            call.set_rgb(r, g, b);
            call.set_white(0.0f);
            call.perform();

      - lambda:
          name: "Police Light"
          update_interval: 50ms
          lambda: |-
            static uint8_t step = 0;
            auto call = id(moodlight_light).turn_on();
            call.set_transition_length(0);
            if (step == 0 || step == 2) {
              call.set_rgb(0.0f, 0.0f, 1.0f);
              call.set_white(0.0f);
              call.perform();
            } else if (step == 5 || step == 7) {
              call.set_rgb(1.0f, 0.0f, 0.0f);
              call.set_white(0.0f);
              call.perform();
            } else {
              id(white_pwm).set_level(0.0f);
              id(red_pwm).set_level(0.0f);
              id(green_pwm).set_level(0.0f);
              id(blue_pwm).set_level(0.0f);
            }
            step = (step + 1) % 10;

      - lambda:
          name: "Fireplace"
          update_interval: 120ms
          lambda: |-
            static uint32_t lfsr1 = 123456789u;
            static uint32_t lfsr2 = 362436069u;
            lfsr1 = lfsr1 * 1664525u + 1013904223u;
            lfsr2 = lfsr2 * 1103515245u + 12345u;
            float noise_fast = ((lfsr1 >> 16) & 0xFFFF) / 65535.0f;
            float noise_slow = ((lfsr2 >> 16) & 0xFFFF) / 65535.0f;
            static float fast = 0.0f;
            static float slow = 0.0f;
            fast = fast * 0.75f + noise_fast * 0.25f;
            slow = slow * 0.94f + noise_slow * 0.06f;
            float flick = 0.75f * slow + 0.25f * fast;
            float brightness = 0.35f + 0.50f * flick;
            float r_base = 1.0f;
            float g_base = 0.06f + 0.08f * flick;
            if (g_base > 0.18f) g_base = 0.18f;
            float b_base = 0.0f;
            float r = r_base * brightness;
            float g = g_base * brightness;
            float b = b_base * brightness;
            float w = 0.001f;
            float user_brightness = id(moodlight_light).remote_values.get_brightness();
            float r_final = r * user_brightness;
            float g_final = g * user_brightness;
            float b_final = b * user_brightness;
            float w_final = w * user_brightness;
            id(red_pwm).set_level(r_final);
            id(green_pwm).set_level(g_final);
            id(blue_pwm).set_level(b_final);
            id(white_pwm).set_level(w_final);

      - lambda:
          name: "Sound Reactive"
          update_interval: 50ms
          lambda: |-
            static uint32_t start_time = esphome::millis();
            uint32_t now = esphome::millis();
            float current_level = id(mic_adc).state;
            float max_level = id(mic_adc_max).state;
            float response = 0.0f;
            if (max_level >= 4.0f) {
              float mic_level = (current_level / max_level);
              mic_level = mic_level > 0.45f ? mic_level : 0.0f;
              if (mic_level > 1.0f) mic_level = 1.0f;
              response = mic_level * mic_level;
            }
            float chase_hue = fmodf((now - start_time) / 20000.0f, 1.0f);
            float hue = fmodf(chase_hue + 0.15f * response, 1.0f);
            float r, g, b;
            float i = floorf(hue * 6.0f);
            float f = hue * 6.0f - i;
            float q = 1.0f - f;
            switch ((int)i % 6) {
              case 0: r = 1.0f; g = f; b = 0.0f; break;
              case 1: r = q; g = 1.0f; b = 0.0f; break;
              case 2: r = 0.0f; g = 1.0f; b = f; break;
              case 3: r = 0.0f; g = q; b = 1.0f; break;
              case 4: r = f; g = 0.0f; b = 1.0f; break;
              case 5: r = 1.0f; g = 0.0f; b = q; break;
              default: r = 1.0f; g = 0.0f; b = 0.0f;
            }
            float brightness = (max_level >= 4.0f) ? (0.3f + 0.6f * response) : 0.5f;
            float white_pulse = (max_level >= 4.0f && response > 0.8f) ? (0.1f * response) : 0.01f;
            auto call = id(moodlight_light).turn_on();
            call.set_transition_length(0);
            call.set_rgb(r * brightness, g * brightness, b * brightness);
            call.set_white(white_pulse);
            call.perform();

number:
  - platform: template
    name: "Rainbow Cycle Duration"
    id: rainbow_cycle_duration
    optimistic: true
    min_value: 5
    max_value: 120
    step: 5
    unit_of_measurement: "s"
    initial_value: 60
    restore_value: true

sensor:
  - platform: adc
    pin: P23
    id: mic_adc
    internal: true
    update_interval: 50ms
    samples: 4
    sampling_mode: max
    raw: true
    filters:
      - calibrate_linear:
          - 0 -> 0.0
          - 636 -> 100.0
      - clamp:
          min_value: 0.0
          max_value: 100.0
          ignore_out_of_range: false
  
  - platform: copy
    source_id: mic_adc
    id: mic_adc_max
    filters:
      - max:
          window_size: 12
          send_every: 3
      - exponential_moving_average:
          alpha: 0.2
          send_every: 1
      